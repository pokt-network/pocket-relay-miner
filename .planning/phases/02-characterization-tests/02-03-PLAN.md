---
phase: 02-characterization-tests
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - miner/session_lifecycle_test.go
  - miner/session_lifecycle_concurrent_test.go
autonomous: true

must_haves:
  truths:
    - "All 10 SessionState values have transition tests"
    - "State machine transitions match determineTransition() logic"
    - "Session discovery and tracking works correctly"
    - "Block event handling triggers correct state transitions"
    - "Concurrent session operations do not race"
  artifacts:
    - path: "miner/session_lifecycle_test.go"
      provides: "State machine transition tests"
      min_lines: 500
    - path: "miner/session_lifecycle_concurrent_test.go"
      provides: "Concurrent session operation tests"
      min_lines: 250
  key_links:
    - from: "miner/session_lifecycle_test.go"
      to: "miner/session_lifecycle.go"
      via: "tests determineTransition, state machine"
      pattern: "determineTransition|SessionState"
    - from: "miner/session_lifecycle_concurrent_test.go"
      to: "xsync.Map"
      via: "tests concurrent access to activeSessions"
      pattern: "activeSessions"
---

<objective>
Add comprehensive characterization tests for miner/session_lifecycle.go covering the complete session state machine with 10 states.

Purpose: Document expected state transition behavior and verify concurrent session tracking. The session lifecycle manager coordinates claim/proof timing - incorrect transitions can cause missed claim windows or lost funds.

Output: Two test files covering state transitions (unit-level) and concurrent operations (integration-level)
</objective>

<execution_context>
@/home/overlordyorch/.claude/get-shit-done/workflows/execute-plan.md
@/home/overlordyorch/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-characterization-tests/02-RESEARCH.md
@.planning/phases/02-characterization-tests/02-CONTEXT.md
@.planning/phases/02-characterization-tests/02-01-SUMMARY.md

# Reference source and existing patterns
@miner/session_lifecycle.go
@miner/session_store.go
@miner/claim_pipeline_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session lifecycle state machine tests</name>
  <files>miner/session_lifecycle_test.go</files>
  <action>
Create miner/session_lifecycle_test.go with comprehensive state machine tests.

Use testify/suite embedding testutil.RedisTestSuite for shared miniredis.

Create SessionLifecycleTestSuite with:
- Embedded testutil.RedisTestSuite
- mockSessionStore (or use RedisSessionStore with miniredis)
- mockSharedQueryClient (reuse from claim_pipeline_test.go)
- mockBlockClient (reuse from claim_pipeline_test.go)
- mockSessionLifecycleCallback (track callback invocations)
- SessionLifecycleManager under test

**State Transition Tests (table-driven for determineTransition):**
Use table-driven subtests for the 10 states:

```go
func (s *SessionLifecycleTestSuite) TestDetermineTransition() {
    tests := []struct {
        name           string
        initialState   SessionState
        currentHeight  int64
        sessionEndHeight int64
        expectedState  SessionState
        expectedAction string
    }{
        // Active -> Claiming when claim window opens
        {"active_to_claiming", SessionStateActive, 106, 104, SessionStateClaiming, "claim_window_open"},
        // Active -> ClaimWindowClosed when claim window timeout
        {"active_to_claim_timeout", SessionStateActive, 120, 104, SessionStateClaimWindowClosed, "claim_window_timeout"},
        // Claiming -> ClaimWindowClosed on timeout
        {"claiming_to_timeout", SessionStateClaiming, 120, 104, SessionStateClaimWindowClosed, "claim_timeout"},
        // Claimed -> Proving when proof window opens
        {"claimed_to_proving", SessionStateClaimed, 115, 104, SessionStateProving, "proof_window_open"},
        // ... more transitions
    }

    for _, tt := range tests {
        s.Run(tt.name, func() {
            // Setup session with initial state
            // Call determineTransition (or trigger via checkSessionTransitions)
            // Assert expected state and action
        })
    }
}
```

**Individual State Tests:**
1. TestActiveState_AcceptsRelays - active sessions can receive relays
2. TestActiveState_TransitionToClaimingOnWindow - claim window opens
3. TestActiveState_TransitionToClaimTimeoutOnExpiry - claim window closes without transition
4. TestClaimingState_WaitsForCallback - no automatic transitions
5. TestClaimingState_TransitionToClaimTimeout - window closes while claiming
6. TestClaimedState_TransitionToProvingOnWindow - proof window opens
7. TestClaimedState_TransitionToProofTimeout - proof window closes
8. TestProvingState_WaitsForCallback - no automatic transitions
9. TestProvingState_TransitionToProofTimeout - window closes while proving
10. TestTerminalStates_NoTransitions - proved, claim_window_closed, etc. are final

**Happy Path Scenarios:**
1. TestReachSettled_HappyPath - Active -> Claiming -> Claimed -> Proving -> Proved
2. TestReachProbabilisticProved - Active -> Claiming -> Claimed -> ProbabilisticProved
3. TestReachClaimFailed - Active -> ClaimWindowClosed (timeout) or ClaimTxError

**Session Tracking Tests:**
1. TestTrackSession_AddsToActiveMap - new sessions tracked
2. TestTrackSession_Duplicate - same session ID handled
3. TestRemoveSession_RemovesFromActiveMap - sessions removed after terminal
4. TestGetSessionsByState_FiltersCorrectly - state-based filtering works

Include //go:build test constraint.
  </action>
  <verify>
```bash
go test -race -v ./miner/... -run "TestSessionLifecycle.*"
```
All tests pass with race detection.
  </verify>
  <done>
- All 10 SessionState values have transition tests
- Table-driven determineTransition tests cover edge cases
- Happy path scenarios (settled, probabilistic, failed) tested
- Session tracking (add, remove, get by state) tested
- Tests pass with -race flag
  </done>
</task>

<task type="auto">
  <name>Task 2: Create session lifecycle concurrency tests</name>
  <files>miner/session_lifecycle_concurrent_test.go</files>
  <action>
Create miner/session_lifecycle_concurrent_test.go with high-concurrency tests.

Use testify/suite embedding testutil.RedisTestSuite.

**Concurrent Session Tracking:**
1. TestConcurrentSessionTracking - 500+ goroutines adding sessions simultaneously
2. TestConcurrentSessionRemoval - 500+ goroutines removing sessions
3. TestConcurrentSessionStateUpdates - multiple threads updating same session state
4. TestConcurrentGetByState - reads while writes happening

**Block Event Concurrency:**
1. TestConcurrentBlockEvents - multiple block events processed simultaneously
2. TestBlockEventDuringTransition - block arrives while transition in progress
3. TestRapidBlockProgression - many blocks in quick succession

**State Race Tests:**
1. TestMultipleRelaysHittingSameSession - concurrent relay processing
2. TestStateTransitionDuringProcessing - transition triggered while operation running
3. TestConcurrentCallbackInvocations - multiple callbacks for different sessions

Use testutil.GetTestConcurrency() for concurrency levels.
All tests MUST pass `go test -race`.
Include //go:build test constraint.

Key pattern:
```go
func (s *SessionLifecycleConcurrentSuite) TestConcurrentSessionTracking() {
    numGoroutines := testutil.GetTestConcurrency()
    var wg sync.WaitGroup
    wg.Add(numGoroutines)

    for i := 0; i < numGoroutines; i++ {
        go func(idx int) {
            defer wg.Done()
            snapshot := testutil.NewSessionBuilder(idx).
                WithState(SessionStateActive).
                Build()
            err := s.manager.TrackSession(s.Ctx, snapshot)
            s.Require().NoError(err)
        }(i)
    }

    wg.Wait()

    // Verify all sessions tracked
    count := 0
    s.manager.activeSessions.Range(func(k string, v *SessionSnapshot) bool {
        count++
        return true
    })
    s.Require().Equal(numGoroutines, count)
}
```
  </action>
  <verify>
```bash
# Run with race detector
go test -race -v ./miner/... -run "TestSessionLifecycleConcurrent.*"

# Stability check (10 runs)
for i in {1..10}; do go test -race ./miner/... -run "TestSessionLifecycleConcurrent.*" || exit 1; done
```
  </verify>
  <done>
- 500+ concurrent session tracking operations tested
- Concurrent block event processing tested
- State race conditions tested (multiple relays, transitions during processing)
- No races detected with -race flag
- Tests pass 10/10 runs (no flakiness)
  </done>
</task>

</tasks>

<verification>
```bash
# All session lifecycle tests pass with race detection
go test -race -v ./miner/... -run "TestSessionLifecycle.*"

# Coverage check for session_lifecycle.go
go test -coverprofile=cover.out ./miner/... -run "TestSessionLifecycle.*"
go tool cover -func=cover.out | grep session_lifecycle.go

# Stability check (10 runs)
for i in {1..10}; do
  echo "Run $i..."
  go test -race ./miner/... -run "TestSessionLifecycle.*" || exit 1
done
echo "All 10 runs passed"
```
</verification>

<success_criteria>
1. All 10 SessionState values have transition tests
2. Table-driven determineTransition tests with edge cases
3. Happy path scenarios tested (settled, probabilistic, failed paths)
4. Session tracking operations tested (add, remove, get by state)
5. Concurrent tests use 500+ goroutines
6. Block event concurrency tested
7. State race conditions tested
8. All tests pass with -race flag
9. 10/10 consecutive runs pass (no flakiness)
10. Coverage of session_lifecycle.go increases to 70%+ (measured via go tool cover)
</success_criteria>

<output>
After completion, create `.planning/phases/02-characterization-tests/02-03-SUMMARY.md`
</output>
