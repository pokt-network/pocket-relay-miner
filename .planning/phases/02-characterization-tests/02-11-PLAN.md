---
phase: 02-characterization-tests
plan: 11
type: execute
wave: 2
depends_on: [02-06]
files_modified:
  - cache/interface_test.go
  - cache/shared_params_singleton_test.go
  - cache/application_cache_test.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Cold cache (L1+L2 miss) fetches from L3 chain query and populates L1+L2 on return"
    - "Warm cache (L1 miss, L2 hit) returns from Redis without triggering chain query"
    - "Hot cache (L1 hit) returns in-memory data without any Redis call"
    - "Cache invalidation clears both L1 and L2, forcing next access to re-fetch from L3"
    - "Concurrent cold-cache Gets for the same key trigger exactly one L3 query (distributed lock)"
    - "All cache tests use miniredis and pass -race flag"
    - "Cache/ coverage reaches >= 20% (up from 0% baseline; 80% enforcement deferred to Phase 6 per ROADMAP.md success criterion 2)"
  artifacts:
    - path: "cache/interface_test.go"
      provides: "CacheKeys and CacheConfig unit tests"
      min_lines: 100
    - path: "cache/shared_params_singleton_test.go"
      provides: "SharedParamsSingleton characterization tests"
      min_lines: 250
    - path: "cache/application_cache_test.go"
      provides: "ApplicationCache characterization tests"
      min_lines: 250
  key_links:
    - from: "cache/interface_test.go"
      to: "cache/interface.go"
      via: "Direct function calls"
      pattern: "CacheKeys\\|CacheConfig\\|BlocksToTTL"
    - from: "cache/shared_params_singleton_test.go"
      to: "cache/shared_params_singleton.go"
      via: "Direct calls with miniredis"
      pattern: "SharedParams\\|Get\\|Set\\|Invalidate"
    - from: "cache/application_cache_test.go"
      to: "cache/application_cache.go"
      via: "Direct calls with miniredis"
      pattern: "ApplicationCache\\|Get\\|Set\\|Invalidate"
    - from: "cache/shared_params_singleton_test.go"
      to: "testutil/redis_suite.go"
      via: "Import for miniredis setup helpers"
      pattern: "testutil\\.NewRedisTestSuite\\|testutil\\.Redis"
    - from: "cache/application_cache_test.go"
      to: "testutil/redis_suite.go"
      via: "Import for miniredis setup helpers"
      pattern: "testutil\\.NewRedisTestSuite\\|testutil\\.Redis"
    - from: "cache/application_cache_test.go"
      to: "testutil/keys.go"
      via: "Import for deterministic test addresses"
      pattern: "testutil\\.TestKeys\\|testutil\\.AppAddress"
---

<objective>
Add characterization tests for the cache package to bring it from 0% coverage.

Purpose: Cache coverage is at 0.0%. The cache package implements the critical three-tier caching system (L1 in-memory, L2 Redis, L3 chain query) used by every relay request. Tests must characterize the L1/L2/L3 fallback pattern, distributed locking, and pub/sub invalidation. This plan focuses on the most representative cache types: interface helpers, shared params singleton (SingletonEntityCache pattern), and application cache (KeyedEntityCache pattern).

Output: Three test files establishing cache package coverage from 0% baseline
</objective>

<execution_context>
@/home/overlordyorch/.claude/get-shit-done/workflows/execute-plan.md
@/home/overlordyorch/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-characterization-tests/02-VERIFICATION.md
@cache/interface.go
@cache/shared_params_singleton.go
@cache/application_cache.go
@cache/pubsub.go
@cache/orchestrator.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cache interface and shared params singleton tests</name>
  <files>
    cache/interface_test.go
    cache/shared_params_singleton_test.go
  </files>
  <action>
    **Build tag:** `//go:build test` at the top of both files.

    **interface_test.go:**

    Test the pure functions and helpers in interface.go:

    1. **TestCacheConfig_DefaultValues**: DefaultCacheConfig() returns expected defaults
    2. **TestCacheConfig_BlocksToTTL**: BlocksToTTL converts blocks to correct duration
    3. **TestCacheKeys_SharedParams**: Key format matches expected pattern
    4. **TestCacheKeys_SharedParamsLock**: Lock key format matches expected pattern
    5. **TestCacheKeys_Session**: Session key includes app, service, height
    6. **TestCacheKeys_SessionByID**: SessionByID key format correct
    7. **TestCacheKeys_SessionValidation**: Validation key format correct
    8. **TestCacheKeys_SupplierParams**: Supplier params key format correct

    These are simple unit tests (no Redis needed).

    **shared_params_singleton_test.go:**

    Read `cache/shared_params_singleton.go` (413 lines) to understand:
    - How the singleton cache stores shared params
    - L1 (xsync.Map or sync atomic) → L2 (Redis) → L3 (chain query) fallback
    - Distributed lock acquisition for L3 queries
    - Pub/sub invalidation subscription
    - The 5ms lock retry timeout (recent optimization)

    Create tests using miniredis and testify/suite:

    1. **TestSharedParamsSingleton_GetFromL3**: Cold cache fetches from L3 (mock chain query), stores in L2+L1
    2. **TestSharedParamsSingleton_GetFromL2**: L1 cold, L2 has data, returns from L2 without L3 query
    3. **TestSharedParamsSingleton_GetFromL1**: L1 has data, returns immediately (no Redis call)
    4. **TestSharedParamsSingleton_Invalidate**: Invalidation clears L1 and L2, next Get fetches from L3
    5. **TestSharedParamsSingleton_SetExplicit**: Explicit Set populates L1 and L2
    6. **TestSharedParamsSingleton_DistributedLock**: Two concurrent Gets for cold cache, only one L3 query fires
    7. **TestSharedParamsSingleton_ConcurrentReads**: Multiple concurrent reads are safe

    **Mock pattern for L3 (chain query):**
    Create a local mock implementing whatever query interface the singleton uses. Track call counts with mutex to verify L3 is only called when expected.

    **Important:** Use `testutil/redis_suite.go` for miniredis setup (plan 06 fixes the import cycle). The cache constructors may require specific dependencies. Read the constructor signature and provide mock implementations for all required dependencies. Use local mock types only for cache-specific dependencies that testutil cannot provide (e.g., chain query interfaces, block event sources). Use miniredis for Redis, and mock interfaces for chain queries.
  </action>
  <verify>
    ```bash
    # Tests compile
    go build -tags test ./cache/...

    # Tests pass with race detector
    go test -tags test -race -v -run "TestCacheConfig|TestCacheKeys|TestSharedParamsSingleton" ./cache/...

    # Tests pass with shuffle
    go test -tags test -race -shuffle=on -run "TestCacheConfig|TestCacheKeys|TestSharedParamsSingleton" ./cache/...
    ```
  </verify>
  <done>
    interface_test.go has 8+ tests. shared_params_singleton_test.go has 7+ tests. All pass with -race and -shuffle=on.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create application cache characterization tests</name>
  <files>cache/application_cache_test.go</files>
  <action>
    **Build tag:** `//go:build test` at the top of file.

    Read `cache/application_cache.go` (472 lines) to understand:
    - How the keyed entity cache stores application data by address
    - L1 (xsync.Map) → L2 (Redis with proto marshaling) → L3 (chain query) pattern
    - TTL handling for cached entries
    - Pub/sub invalidation for specific keys
    - The distributed lock pattern for concurrent L3 queries
    - How "known entities" tracking works (ha:cache:known:{type} set)

    Create tests using miniredis and testify/suite:

    1. **TestApplicationCache_GetFromL3**: Cold cache for app address fetches from L3, stores in L2+L1
    2. **TestApplicationCache_GetFromL2**: L1 cold, L2 has serialized app, returns from L2
    3. **TestApplicationCache_GetFromL1**: L1 has app, returns without Redis call
    4. **TestApplicationCache_GetForceRefresh**: Get with force=true bypasses L1/L2, queries L3
    5. **TestApplicationCache_InvalidateKey**: Invalidating an app address clears it from L1 and L2
    6. **TestApplicationCache_InvalidateAll**: InvalidateAll clears all cached apps
    7. **TestApplicationCache_TTLExpiry**: Verify that L2 entries expire after TTL (use miniredis FastForward)
    8. **TestApplicationCache_SetExplicit**: Explicit Set stores in L1+L2 with TTL
    9. **TestApplicationCache_MultipleKeys**: Different app addresses cached independently
    10. **TestApplicationCache_ConcurrentGetSameKey**: Multiple concurrent Gets for same cold key trigger single L3 query

    **Mock pattern for L3:** Same as Task 1 - mock the chain query interface with call counting.

    **Important:** Use `testutil/redis_suite.go` for miniredis setup and `testutil/keys.go` for deterministic test addresses. Use `miniredis.FastForward(duration)` to simulate time passing for TTL tests (deterministic, no time.Sleep). Use proto.Marshal/Unmarshal for test data if the cache stores protobuf-encoded data. Use local mock types only for cache-specific chain query interfaces.
  </action>
  <verify>
    ```bash
    # Tests compile
    go build -tags test ./cache/...

    # Tests pass with race detector
    go test -tags test -race -v -run TestApplicationCache ./cache/...

    # Tests pass with shuffle
    go test -tags test -race -shuffle=on -run TestApplicationCache ./cache/...

    # Run coverage to see improvement
    go test -tags test -race -coverprofile=/tmp/cache.cover ./cache/... && go tool cover -func=/tmp/cache.cover | grep total
    ```
  </verify>
  <done>
    application_cache_test.go has 10+ tests. All pass with -race and -shuffle=on. Cache coverage is >= 20% (up from 0% baseline).
  </done>
</task>

</tasks>

<verification>
1. `go test -tags test -race -v ./cache/...` passes all cache tests
2. `go test -tags test -race -shuffle=on -count=3 ./cache/...` passes (no flaky tests)
3. Combined: 25+ new tests across 3 files
4. Cache coverage >= 20% (up from 0% baseline; 80% enforcement deferred to Phase 6)
5. Cache tests run with `go test -p 1 -parallel 1` due to shared miniredis (per TESTING.md)
</verification>

<success_criteria>
- Cache package has characterization tests from 0% baseline
- Tests cover both SingletonEntityCache and KeyedEntityCache patterns
- All new tests use miniredis, pass -race, run deterministically
- Cache/ coverage >= 20% (80% enforcement deferred to Phase 6 per ROADMAP.md success criterion 2)
</success_criteria>

<output>
After completion, create `.planning/phases/02-characterization-tests/02-11-SUMMARY.md`
</output>
