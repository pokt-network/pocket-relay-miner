---
phase: 02-characterization-tests
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - miner/lifecycle_callback_states_test.go
  - miner/lifecycle_callback_concurrent_test.go
autonomous: true

must_haves:
  truths:
    - "All state transitions in lifecycle_callback.go are tested"
    - "Claim path (OnSessionsNeedClaim) handles success, window timeout, and TX errors"
    - "Proof path (OnSessionsNeedProof) handles success, probabilistic skip, window timeout, and TX errors"
    - "Concurrent claim/proof operations do not race"
    - "Tests run deterministically with miniredis"
  artifacts:
    - path: "miner/lifecycle_callback_states_test.go"
      provides: "State transition tests for lifecycle callback"
      min_lines: 400
    - path: "miner/lifecycle_callback_concurrent_test.go"
      provides: "Concurrency tests for lifecycle callback"
      min_lines: 200
  key_links:
    - from: "miner/lifecycle_callback_states_test.go"
      to: "miner/lifecycle_callback.go"
      via: "tests OnSessionsNeedClaim, OnSessionsNeedProof"
      pattern: "OnSessions(Need)?Claim|OnSessions(Need)?Proof"
    - from: "miner/lifecycle_callback_concurrent_test.go"
      to: "testutil.RedisTestSuite"
      via: "embeds suite for Redis isolation"
      pattern: "testutil\\.RedisTestSuite"
---

<objective>
Add comprehensive characterization tests for miner/lifecycle_callback.go covering all state transitions in the claim and proof paths.

Purpose: Document expected behavior of the LifecycleCallback state machine and enable safe refactoring. The claim/proof paths are "money paths" - bugs here lose funds.

Output: Two test files covering state transitions (unit-level) and concurrent operations (integration-level)
</objective>

<execution_context>
@/home/overlordyorch/.claude/get-shit-done/workflows/execute-plan.md
@/home/overlordyorch/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-characterization-tests/02-RESEARCH.md
@.planning/phases/02-characterization-tests/02-CONTEXT.md
@.planning/phases/02-characterization-tests/02-01-SUMMARY.md

# Reference existing patterns
@miner/lifecycle_callback.go
@miner/lifecycle_callback_test.go
@miner/claim_pipeline_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lifecycle callback state transition tests</name>
  <files>miner/lifecycle_callback_states_test.go</files>
  <action>
Create miner/lifecycle_callback_states_test.go with comprehensive state transition tests.

Use testify/suite embedding testutil.RedisTestSuite for shared miniredis.

Create LifecycleCallbackTestSuite with:
- Embedded testutil.RedisTestSuite
- mockSMSTManager (reuse pattern from claim_pipeline_test.go)
- mockTxClient (reuse pattern from claim_pipeline_test.go)
- mockSharedQueryClient
- mockBlockClient

**Claim Path Tests (OnSessionsNeedClaim):**
1. TestOnSessionsNeedClaim_Success - happy path, claims submitted
2. TestOnSessionsNeedClaim_BatchMultipleSessions - multiple sessions in single TX
3. TestOnSessionsNeedClaim_FlushTreeError - SMST flush fails
4. TestOnSessionsNeedClaim_TxSubmissionError - claim TX fails
5. TestOnSessionsNeedClaim_WindowTimeout - claim window closes before submission
6. TestOnSessionsNeedClaim_EconomicViabilityCheck - sessions below threshold skipped
7. TestOnSessionsNeedClaim_DeduplicationCleanup - dedup entries cleaned after success

**Proof Path Tests (OnSessionsNeedProof):**
1. TestOnSessionsNeedProof_Success - proof submitted successfully
2. TestOnSessionsNeedProof_BatchMultipleSessions - multiple proofs in single TX
3. TestOnSessionsNeedProof_ProofNotRequired - probabilistic proof skip
4. TestOnSessionsNeedProof_ProveClosestError - SMST proof generation fails
5. TestOnSessionsNeedProof_TxSubmissionError - proof TX fails
6. TestOnSessionsNeedProof_WindowTimeout - proof window closes before submission

**Terminal State Callbacks:**
1. TestOnSessionProved_CleansResources - SMST deleted, dedup cleaned
2. TestOnProbabilisticProved_CleansResources - same cleanup path
3. TestOnClaimWindowClosed_CleansResources - SMST deleted on failure
4. TestOnClaimTxError_CleansResources
5. TestOnProofWindowClosed_CleansResources
6. TestOnProofTxError_CleansResources

Use thread-safe mock patterns (sync.Mutex for call tracking) from claim_pipeline_test.go.
Include //go:build test constraint.
  </action>
  <verify>
```bash
go test -race -v ./miner/... -run "TestLifecycleCallback.*"
```
All tests pass with race detection.
  </verify>
  <done>
- All claim path transitions tested (success, batch, flush error, TX error, window timeout, economic viability, dedup cleanup)
- All proof path transitions tested (success, batch, not required, prove error, TX error, window timeout)
- All terminal state callbacks tested for resource cleanup
- Tests pass with -race flag
  </done>
</task>

<task type="auto">
  <name>Task 2: Create lifecycle callback concurrency tests</name>
  <files>miner/lifecycle_callback_concurrent_test.go</files>
  <action>
Create miner/lifecycle_callback_concurrent_test.go with high-concurrency tests.

Use testify/suite embedding testutil.RedisTestSuite.

**Concurrent Claim Tests:**
1. TestConcurrentClaimSubmissions - 500+ concurrent OnSessionsNeedClaim calls
2. TestClaimDuringProof - claim and proof operations interleaved
3. TestConcurrentSameSession - multiple threads trying same session (lock contention)

**Concurrent Proof Tests:**
1. TestConcurrentProofSubmissions - 500+ concurrent OnSessionsNeedProof calls
2. TestProofDuringCleanup - proof generation while terminal callback running

**Race Condition Tests:**
1. TestSessionLockContention - multiple goroutines acquiring same session lock
2. TestConcurrentCallbacksNoRace - run all callbacks concurrently, verify no races
3. TestCleanupDuringActiveOperation - terminal cleanup called while claim/proof in progress

Use testutil.GetTestConcurrency() for concurrency levels (100 CI, 1000 nightly).
All tests MUST pass `go test -race`.
Include //go:build test constraint.

Key pattern for concurrent tests:
```go
func (s *LifecycleCallbackConcurrentSuite) TestConcurrentClaimSubmissions() {
    numGoroutines := testutil.GetTestConcurrency()
    var wg sync.WaitGroup
    wg.Add(numGoroutines)

    errors := make(chan error, numGoroutines)

    for i := 0; i < numGoroutines; i++ {
        go func(idx int) {
            defer wg.Done()
            snapshot := testutil.NewSessionBuilder(idx).Build()
            _, err := s.callback.OnSessionsNeedClaim(s.Ctx, []*SessionSnapshot{snapshot})
            if err != nil {
                errors <- err
            }
        }(i)
    }

    wg.Wait()
    close(errors)

    for err := range errors {
        s.FailNow("unexpected error: %v", err)
    }
}
```
  </action>
  <verify>
```bash
# Run with race detector
go test -race -v ./miner/... -run "TestLifecycleCallbackConcurrent.*"

# Run 10 times to check for flakiness
for i in {1..10}; do go test -race ./miner/... -run "TestLifecycleCallbackConcurrent.*" || exit 1; done
```
  </verify>
  <done>
- 500+ concurrent claim submissions tested
- 500+ concurrent proof submissions tested
- Session lock contention tested
- No races detected with -race flag
- Tests pass 10/10 runs (no flakiness)
  </done>
</task>

</tasks>

<verification>
```bash
# All lifecycle callback tests pass with race detection
go test -race -v ./miner/... -run "TestLifecycleCallback.*"

# Coverage check for lifecycle_callback.go
go test -coverprofile=cover.out ./miner/... -run "TestLifecycleCallback.*"
go tool cover -func=cover.out | grep lifecycle_callback.go

# Stability check (10 runs)
for i in {1..10}; do
  echo "Run $i..."
  go test -race ./miner/... -run "TestLifecycleCallback.*" || exit 1
done
echo "All 10 runs passed"
```
</verification>

<success_criteria>
1. All state transition tests exist and pass
2. Claim path tests cover: success, batch, flush error, TX error, window timeout, economic viability, dedup cleanup
3. Proof path tests cover: success, batch, not required, prove error, TX error, window timeout
4. Terminal callbacks test resource cleanup (SMST deletion, dedup cleanup)
5. Concurrent tests use 500+ goroutines (configurable via TEST_MODE)
6. All tests pass with -race flag
7. 10/10 consecutive runs pass (no flakiness)
8. Coverage of lifecycle_callback.go increases to 70%+ (measured via go tool cover)
</success_criteria>

<output>
After completion, create `.planning/phases/02-characterization-tests/02-02-SUMMARY.md`
</output>
