---
phase: 02-characterization-tests
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - relayer/proxy_test.go
  - relayer/proxy_concurrent_test.go
  - relayer/relay_processor_test.go
autonomous: true

must_haves:
  truths:
    - "HTTP relay handling tested for success and error paths"
    - "Response signing verified for valid relays"
    - "Request validation rejects invalid relays correctly"
    - "Concurrent relay processing does not race"
    - "Observable behavior (response format, error codes) verified"
  artifacts:
    - path: "relayer/proxy_test.go"
      provides: "HTTP transport and relay handling tests"
      min_lines: 400
    - path: "relayer/proxy_concurrent_test.go"
      provides: "Concurrent relay processing tests"
      min_lines: 200
    - path: "relayer/relay_processor_test.go"
      provides: "Relay validation and signing tests"
      min_lines: 300
  key_links:
    - from: "relayer/proxy_test.go"
      to: "relayer/proxy.go"
      via: "tests handleRelay, backend forwarding"
      pattern: "handleRelay|ServeHTTP"
    - from: "relayer/relay_processor_test.go"
      to: "relayer/relay_validator.go"
      via: "tests validation logic"
      pattern: "RelayValidator|Validate"
---

<objective>
Add comprehensive characterization tests for relayer/proxy.go and relayer/relay_processor.go covering HTTP transport handling and relay validation.

Purpose: Document expected relay processing behavior and verify the system handles concurrent load correctly. The relayer is the performance-critical path handling 1000+ RPS.

Output: Three test files covering HTTP transport, concurrent operations, and relay validation/signing
</objective>

<execution_context>
@/home/overlordyorch/.claude/get-shit-done/workflows/execute-plan.md
@/home/overlordyorch/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-characterization-tests/02-RESEARCH.md
@.planning/phases/02-characterization-tests/02-CONTEXT.md
@.planning/phases/02-characterization-tests/02-01-SUMMARY.md

# Reference source files
@relayer/proxy.go
@relayer/relay_validator.go
@relayer/relay_processor.go
@relayer/response_signer.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create proxy HTTP transport tests</name>
  <files>relayer/proxy_test.go</files>
  <action>
Create relayer/proxy_test.go with HTTP transport and relay handling tests.

Use testify/suite with httptest.Server for backend simulation.

Create ProxyTestSuite with:
- httptest.Server for mock backend
- ProxyServer under test
- Mock components (validator, signer, publisher, meter)

**HTTP Handling Tests:**
1. TestHandleRelay_Success - valid relay forwarded to backend, response signed
2. TestHandleRelay_BackendTimeout - backend doesn't respond in time
3. TestHandleRelay_Backend5xx - backend returns 500
4. TestHandleRelay_BackendNetworkError - backend unreachable
5. TestHandleRelay_ClientDisconnect - client disconnects mid-request
6. TestHandleRelay_BodyTooLarge - request body exceeds limit
7. TestHandleRelay_InvalidRelayRequest - malformed relay request

**Response Handling Tests:**
1. TestResponseSigning_Success - response properly signed
2. TestResponseSigning_Error - signing failure handled
3. TestResponseCompression_Gzip - gzip compression applied when requested
4. TestStreaming_SSE - Server-Sent Events forwarded correctly
5. TestStreaming_NDJSON - NDJSON streaming works

**Supplier/Service Resolution Tests:**
1. TestSupplierNotFound - unknown supplier address rejected
2. TestSupplierInactive - inactive supplier rejected
3. TestServiceNotConfigured - unknown service rejected
4. TestBackendUnhealthy - health checker marks backend unhealthy

**Error Response Format Tests:**
1. TestErrorResponse_ValidationFailed - proper error JSON returned
2. TestErrorResponse_BackendError - backend errors propagated correctly
3. TestErrorResponse_InternalError - internal errors don't leak details

Focus on observable behavior (HTTP status codes, response bodies, headers).
Use httptest.NewServer for backend simulation.
Include //go:build test constraint.
  </action>
  <verify>
```bash
go test -race -v ./relayer/... -run "TestProxy.*"
```
All tests pass with race detection.
  </verify>
  <done>
- HTTP relay handling tested (success, timeout, 5xx, network error, disconnect)
- Response signing verified
- Streaming (SSE, NDJSON) tested
- Supplier/service resolution tested
- Error response format tested
- Tests pass with -race flag
  </done>
</task>

<task type="auto">
  <name>Task 2: Create proxy concurrency tests</name>
  <files>relayer/proxy_concurrent_test.go</files>
  <action>
Create relayer/proxy_concurrent_test.go with high-concurrency tests.

Use testify/suite with httptest.Server.

**Concurrent Relay Processing:**
1. TestConcurrentRelays_500Plus - 500+ concurrent relay requests
2. TestConcurrentRelays_MixedServices - different services simultaneously
3. TestConcurrentRelays_SameSession - multiple relays to same session
4. TestConcurrentRelays_DifferentSuppliers - multiple suppliers

**Worker Pool Tests:**
1. TestWorkerPoolLoad_HighConcurrency - pools handle 500+ concurrent tasks
2. TestWorkerPoolLoad_ValidationSubpool - validation subpool under load
3. TestWorkerPoolLoad_PublishSubpool - publish subpool under load

**Connection Pool Tests:**
1. TestConnectionPoolReuse - connections reused across requests
2. TestConnectionPoolExhaustion - behavior when pool exhausted
3. TestConnectionPoolUnderLoad - pool handles 500+ concurrent connections

**Cache Invalidation Races:**
1. TestCacheInvalidationDuringRead - L1 updates while reads in progress
2. TestSupplierCacheRace - supplier cache reads during updates

Use testutil.GetTestConcurrency() for concurrency levels.
All tests MUST pass `go test -race`.
Include //go:build test constraint.

Key pattern:
```go
func (s *ProxyConcurrentSuite) TestConcurrentRelays_500Plus() {
    numGoroutines := testutil.GetTestConcurrency()
    var wg sync.WaitGroup
    wg.Add(numGoroutines)

    successCount := atomic.Int32{}
    errorCount := atomic.Int32{}

    for i := 0; i < numGoroutines; i++ {
        go func(idx int) {
            defer wg.Done()
            req := s.createTestRelayRequest(idx)
            resp := httptest.NewRecorder()
            s.proxy.ServeHTTP(resp, req)
            if resp.Code == 200 {
                successCount.Add(1)
            } else {
                errorCount.Add(1)
            }
        }(i)
    }

    wg.Wait()
    s.Require().Equal(int32(numGoroutines), successCount.Load())
}
```
  </action>
  <verify>
```bash
# Run with race detector
go test -race -v ./relayer/... -run "TestProxyConcurrent.*"

# Stability check (10 runs)
for i in {1..10}; do go test -race ./relayer/... -run "TestProxyConcurrent.*" || exit 1; done
```
  </verify>
  <done>
- 500+ concurrent relay requests tested
- Worker pool load tested
- Connection pool behavior tested
- Cache invalidation races tested
- No races detected with -race flag
- Tests pass 10/10 runs (no flakiness)
  </done>
</task>

<task type="auto">
  <name>Task 3: Create relay processor tests</name>
  <files>relayer/relay_processor_test.go</files>
  <action>
Create relayer/relay_processor_test.go with relay validation and processing tests.

Use testify/suite.

**Validation Tests:**
1. TestValidation_ValidRelay - valid relay passes all checks
2. TestValidation_MissingServiceID - service ID required
3. TestValidation_MissingSupplierAddress - supplier address required
4. TestValidation_InvalidSignature - bad ring signature rejected
5. TestValidation_ExpiredSession - session end height passed
6. TestValidation_WrongSupplier - relay for different supplier

**Metering Tests:**
1. TestMeter_StakeAvailable - stake check passes
2. TestMeter_StakeExhausted - stake exhausted rejects relay
3. TestMeter_ComputeUnitsTracked - CUs tracked correctly

**Signing Tests:**
1. TestSigning_ValidResponse - response properly signed
2. TestSigning_IncludesMetadata - signature includes service/supplier metadata
3. TestSigning_DeterministicOutput - same input produces same signature

**Publishing Tests:**
1. TestPublish_RelayPublishedToStream - relay published to Redis stream
2. TestPublish_FailureHandled - publish failure doesn't crash

**Pipeline Integration Tests:**
1. TestPipeline_ValidRelay_FullPath - validation -> metering -> signing -> publish
2. TestPipeline_ValidationFailure_NoPublish - failed validation doesn't publish
3. TestPipeline_MeterFailure_NoSign - meter failure stops pipeline

Include //go:build test constraint.
  </action>
  <verify>
```bash
go test -race -v ./relayer/... -run "TestRelayProcessor.*|TestValidation.*|TestMeter.*|TestSigning.*|TestPublish.*|TestPipeline.*"
```
All tests pass with race detection.
  </verify>
  <done>
- Validation tests cover all rejection reasons
- Metering tests verify stake tracking
- Signing tests verify response signatures
- Publishing tests verify Redis stream integration
- Pipeline integration tests verify full flow
- Tests pass with -race flag
  </done>
</task>

</tasks>

<verification>
```bash
# All relayer tests pass with race detection
go test -race -v ./relayer/...

# Coverage check for proxy.go and relay_processor.go
go test -coverprofile=cover.out ./relayer/...
go tool cover -func=cover.out | grep -E "proxy.go|relay_processor.go|relay_validator.go"

# Stability check (10 runs)
for i in {1..10}; do
  echo "Run $i..."
  go test -race ./relayer/... || exit 1
done
echo "All 10 runs passed"
```
</verification>

<success_criteria>
1. HTTP transport tests cover success and all error paths
2. Response signing and streaming verified
3. Supplier/service resolution tested
4. Error response formats verified
5. Concurrent tests use 500+ goroutines
6. Worker pool and connection pool behavior tested
7. Validation, metering, signing, publishing all tested
8. Pipeline integration tested
9. All tests pass with -race flag
10. 10/10 consecutive runs pass (no flakiness)
11. Combined coverage of proxy.go, relay_processor.go, relay_validator.go reaches 60%+
</success_criteria>

<output>
After completion, create `.planning/phases/02-characterization-tests/02-04-SUMMARY.md`
</output>
