# Pocket RelayMiner Miner Configuration Example
# This file uses LOCALNET defaults - ready for local development with Tilt.
# For PRODUCTION, see comments marked [PRODUCTION] for recommended values.
#
# This is the MINER component (stateful claim/proof submitter with leader election).
# For the RELAYER component, see config.relayer.example.yaml

# ==============================================================================
# Redis Configuration (REQUIRED)
# ==============================================================================
redis:
  # Redis connection URL (supports single node, sentinel, cluster)
  url: "redis://localhost:6379"
  # [PRODUCTION] url: "redis://user:password@redis-host:6379/0"
  # [PRODUCTION] url: "redis-sentinel://sentinel1:26379,sentinel2:26379/mymaster?db=0"

  # Consumer name (auto-generated from hostname if not set)
  consumer_name: ""

  # Timeouts
  # Note: XREADGROUP uses BLOCK 0 (TRUE PUSH) for live consumption - not configurable
  claim_idle_timeout_ms: 60000  # Reclaim idle messages after 60s (crashed consumer recovery)

  # Connection pool settings
  # Pool size must accommodate blocked + non-blocked connections:
  #
  # BLOCKED (held indefinitely):
  #   - 1 per supplier: XREADGROUP BLOCK 0 (stream consumption)
  #   - 1: Block event pub/sub
  #   - 2-3: Cache invalidation pub/sub
  #   - 1: Supplier registry pub/sub
  #
  # NON-BLOCKED (share pool, fast release):
  #   - SMST operations, ACK batches, session store, cache, leader heartbeat
  #
  # Formula: pool_size = numSuppliers + 20 overhead
  #   - 1 supplier:   1 + 20 = 21 connections
  #   - 10 suppliers: 10 + 20 = 30 connections
  #   - 100 suppliers: 100 + 20 = 120 connections
  #
  # Default: 50 (handles up to ~30 suppliers)
  # pool_size: 50
  # min_idle_conns: 10               # Warm idle connections
  # pool_timeout_seconds: 4          # Wait time for connection from pool
  # conn_max_idle_time_seconds: 300  # Close idle connections after 5 minutes

  # Namespace configuration (optional - defaults match historical "ha:" prefix structure)
  # All Redis key prefixes are derived from this config.
  # Must match between miner and relayer for proper operation.
  # namespace:
  #   base_prefix: "ha"                # Root prefix for all keys (default: "ha")
  #   cache_prefix: "cache"            # Cache data: ha:cache:* (default: "cache")
  #   events_prefix: "events"          # Pub/sub channels: ha:events:* (default: "events")
  #   streams_prefix: "relays"         # Relay streams: ha:relays:* (default: "relays")
  #   miner_prefix: "miner"            # Miner state: ha:miner:* (default: "miner")
  #   supplier_prefix: "supplier"      # Supplier data: ha:supplier:* (default: "supplier")
  #   meter_prefix: "meter"            # Metering data: ha:meter:* (default: "meter")
  #   params_prefix: "params"          # Cached params: ha:params:* (default: "params")
  #   consumer_group_prefix: "miners"  # Consumer group: ha-miners (default: "miners")

# ==============================================================================
# Pocket Blockchain Connection (REQUIRED)
# ==============================================================================
pocket_node:
  # Query node endpoints (localnet defaults)
  query_node_rpc_url: "http://localhost:26657"  # RPC for queries, blocks, and TX submission
  query_node_grpc_url: "localhost:9090"  # gRPC for queries
  # [PRODUCTION] query_node_rpc_url: "https://rpc.testnet.pokt.network"
  # [PRODUCTION] query_node_grpc_url: "grpc.testnet.pokt.network:443"

  # Chain ID for transaction signing (CRITICAL for non-mainnet chains)
  # MUST match the blockchain you're connecting to, otherwise TX signatures will fail!
  # Examples:
  #   - "pocket" (mainnet)
  #   - "pocket-beta" (testnet)
  #   - "pocket" (localnet)
  # Default: "pocket" (for backward compatibility)
  chain_id: "pocket"  # Localnet
  # [PRODUCTION MAINNET] chain_id: "pocket"
  # [PRODUCTION TESTNET] chain_id: "pocket-beta"

  # gRPC settings
  grpc_insecure: true  # Disable TLS for gRPC (localnet)
  # [PRODUCTION] grpc_insecure: false

  # Query timeout
  query_timeout_seconds: 5  # Timeout for blockchain queries (default: 5s)

# ==============================================================================
# Transaction Configuration (Claim/Proof Submission)
# ==============================================================================
# transaction:
  # Gas limit for transactions
  # Set to 0 for automatic gas estimation (simulation) - RECOMMENDED for production
  # Set to a positive value for a fixed gas limit
  # Default: 0 (automatic estimation via simulation)
  # gas_limit: 0

  # Gas price in upokt (1 POKT = 1,000,000 upokt)
  # Default: "0.00001upokt"
  # gas_price: "0.00001upokt"

  # Gas adjustment factor (multiplier applied to simulated gas)
  # Only used when gas_limit=0 (automatic gas estimation via simulation)
  # Adds safety margin: actual_gas = simulated_gas * gas_adjustment
  # Default: 1.7 (adds 70% safety margin to simulated gas)
  # Increase if transactions fail with code 11 (out of gas) despite simulation
  # gas_adjustment: 1.7

  # NOTE: Unordered transactions with SYNC broadcast mode
  # We use unordered=true with 2-minute timeout_timestamp to eliminate account
  # sequence mismatch errors. SYNC mode returns immediately after CheckTx (mempool
  # acceptance) without waiting for block inclusion, so no commit polling is needed.

# ==============================================================================
# Supplier Keys Configuration (REQUIRED)
# ==============================================================================
keys:
  # Option 1: Load from YAML file with hex-encoded keys
  keys_file: "/keys/supplier-keys.yaml"

  # Option 2: Load from directory with individual key files
  # keys_dir: "/keys/suppliers"

  # Option 3: Use Cosmos SDK keyring (recommended for production)
  # keyring:
  #   backend: "file"  # file, os, test, memory
  #   dir: "/keys/keyring"
  #   app_name: "pocket"
  #   key_names:  # Optional: specific keys to load (empty = load all)
  #     - "supplier1"
  #     - "supplier2"

# ==============================================================================
# Explicit Supplier Configuration (OPTIONAL)
# ==============================================================================
# If not specified, suppliers are auto-discovered from keys.
# Use this for explicit control over which suppliers/services to handle.
# suppliers:
#   - operator_address: "pokt1abc..."
#     signing_key_name: "supplier1"  # Must match key in keyring/keys file
#     services:  # Optional: filter which services this supplier handles
#       - "develop"
#       - "eth-mainnet"

# ==============================================================================
# Block Time Configuration (Feature 1)
# ==============================================================================
block_time_seconds: 10  # Expected block time (localnet uses faster blocks)
# [PRODUCTION] block_time_seconds: 30  # Mainnet/testnet use 30s blocks

# Block health monitoring
block_health_monitor:
  enabled: true  # Monitor for slow blocks (fullnode lag/network issues)
  slowness_threshold: 1.5  # Alert if blocks > 1.5× configured time (e.g., >15s for 10s blocks)

# ==============================================================================
# Balance and Stake Monitoring (Feature 4)
# ==============================================================================
balance_monitor:
  enabled: true  # Enable proactive balance/stake monitoring
  check_interval_seconds: 300  # Check every 5 minutes

  # Balance threshold (in upokt: 1 POKT = 1,000,000 upokt)
  # Set based on your daily TX volume and desired buffer
  # Example calculation:
  #   - Average TX fee: 0.5 upokt
  #   - Daily TXs (claims + proofs): ~1800 (at 5x load with batching)
  #   - Daily cost: 1800 × 0.5 = 900 upokt
  #   - Recommended threshold: 2-3 days buffer = 1800-2700 upokt
  # Default: 1,000,000 upokt (1 POKT) - adjust based on your operations
  balance_threshold_upokt: 1000000  # Alert if balance < 1 POKT

  # Stake health monitoring - alerts based on missed proofs until auto-unstake
  # Formula: missedProofsRemaining = (currentStake - minStake) / proofMissingPenalty
  # These thresholds trigger alerts when you're running low on buffer before auto-unstake
  #
  # WARNING threshold: Alert when < 1000 missed proofs away from auto-unstake
  # CRITICAL threshold: Alert when < 100 missed proofs away from auto-unstake
  #
  # Example with mainnet values:
  #   - Current stake: 60,000,000,000 upokt (60,000 POKT)
  #   - Minimum stake: 59,500,000,000 upokt (59,500 POKT)
  #   - Proof missing penalty: 1 upokt per missed proof
  #   - Buffer: 500,000,000 upokt = 500 million missed proofs (very safe)
  #   - You'd get WARNING when buffer drops below 1000 missed proofs
  #   - You'd get CRITICAL when buffer drops below 100 missed proofs
  stake_warning_proof_threshold: 10   # Warn when < 10 missed proofs remaining
  stake_critical_proof_threshold: 3    # Critical when < 3 missed proofs remaining

# ==============================================================================
# Session Lifecycle Configuration
# ==============================================================================
# NOTE: Session lifecycle is event-driven (uses block events instead of polling)
# NOTE: Submission timing is handled by the protocol's built-in deterministic spreading
#       via GetEarliestSupplierClaimCommitHeight() - no manual buffers needed.
session_lifecycle:
  # Concurrent transitions (claim/proof building is parallelized for performance)
  max_concurrent_transitions: 10  # Limit parallel claim/proof submission batches

# ==============================================================================
# Worker Pool Configuration
# ==============================================================================
# Controls parallelism for claim/proof submission and other background work.
# Auto-sizing formula: max(cpu × cpu_multiplier, suppliers × workers_per_supplier) + overhead
#
# Example sizing (4 CPU, 78 suppliers):
#   max(4 × 4, 78 × 2) + 22 = max(16, 156) + 22 = 178 workers
#
# For high supplier counts, the pool scales with supplier count to ensure
# all suppliers can submit claims/proofs in parallel during claim windows.
#
# worker_pools:
#   master_pool_size: 0           # 0 = auto-calculate (recommended)
#   cpu_multiplier: 4             # CPU multiplier for baseline sizing
#   workers_per_supplier: 2       # Workers per supplier (claim + proof parallel)
#   query_workers: 20             # Fixed workers for blockchain queries
#   settlement_workers: 2         # Fixed workers for settlement events

# ==============================================================================
# Leader Election Configuration (HA Deployments)
# ==============================================================================
leader_election:
  leader_ttl_seconds: 30  # Leader lock TTL (must renew before expiry)
  heartbeat_rate_seconds: 10  # Attempt acquire/renew every 10s

# ==============================================================================
# Supplier Claiming (HA Multi-Miner) - Automatic, No Configuration Needed
# ==============================================================================
# Suppliers are automatically distributed across miner replicas using Redis leases.
# - Single miner: Claims all configured suppliers
# - Multiple miners: Fair distribution with automatic rebalancing
#
# How it works:
#   1. Each miner claims suppliers via Redis SET NX with TTL (30s)
#   2. Miners register in an "active" set with heartbeat (every 10s)
#   3. Fair share is calculated: ceil(totalSuppliers / activeMiners)
#   4. Rebalancing releases excess claims when new miners join (every 30s)
#   5. If a miner crashes, its claims expire after 30s
#
# Example with 3 miners and 9 suppliers:
#   - Fair share = ceil(9/3) = 3 suppliers per miner
#   - Each miner claims up to 3 suppliers
#   - If miner-1 crashes, miner-2 and miner-3 claim its 3 suppliers
#
# Timing values are HARDCODED (not configurable) to ensure production reliability:
#   - ClaimTTL: 30s (time before claim expires)
#   - RenewRate: 10s (claims renewed 3x before expiry)
#   - InstanceTTL: 30s (miner registration TTL)
#   - RebalanceInterval: 30s (redistribution check interval)
#   - Maximum failover time: ~60s (ClaimTTL + RebalanceInterval)
#
# See miner/supplier_claimer.go for the constant definitions.

# ==============================================================================
# Processing Configuration
# ==============================================================================
# NOTE: Session trees (SMST) are always stored in Redis and committed after each relay.
# Redis streams serve as the WAL for relays, enabling HA compatibility and data durability.
deduplication_ttl_blocks: 10  # Keep relay hashes for 10 blocks to prevent duplicates
batch_size: 1000  # Relay batch size for XREADGROUP (increased from 100 for better throughput)
ack_batch_size: 50  # Acknowledge messages in batches (pipelined Redis XACK)
hot_reload_enabled: true  # Enable hot-reload of keys on startup
cache_ttl: "2h"  # TTL for Redis cached data (sessions, SMST trees). Default 2h covers ~15 session lifecycles at 30s blocks. Backup safety net if manual cleanup fails.

# Submission tracking TTL (for debugging claim/proof submissions)
# Tracks tx hashes, success/failure, errors, and timing for post-mortem analysis.
# Use `pocket-relay-miner redis submissions` to inspect tracked data.
submission_tracking_ttl: "24h"  # Default: 24h (covers multiple session windows for debugging)
# [PRODUCTION] submission_tracking_ttl: "168h"  # 7 days for longer audit trail

# Pre-discovered applications (optional - speeds up startup)
known_applications:
  - "pokt1mrqt5f7qh8uxs27cjm9t7v9e74a9vvdnq5jva4"  # app1
  - "pokt184zvylazwu4queyzpl0gyz9yf5yxm2kdhh9hpm"  # app2
  - "pokt1lqyu4v88vp8tzc86eaqr4lq8rwhssyn6rfwzex"  # app3
  - "pokt1pn64d94e6u5g8cllsnhgrl6t96ysnjw59j5gst"  # app4

# ==============================================================================
# ServiceFactor Configuration (Economic Policy)
# ==============================================================================
# ServiceFactor controls how much of the application's stake the supplier will accept for billing.
# This is configured on the MINER ONLY and shared with relayers via Redis.
#
# How it works:
#   - If serviceFactor is SET: effectiveLimit = appStake × serviceFactor
#   - If serviceFactor is NOT SET: effectiveLimit = (appStake / numSuppliers) / proof_window_close_offset_blocks
#
# The baseLimit formula gives the MOST CONSERVATIVE calculation:
#   baseLimit = (appStake / numSuppliersPerSession) / proof_window_close_offset_blocks
#
# IMPORTANT: The protocol NEVER guarantees any payment amount!
# Due to race conditions, claim ordering, and session dynamics, actual settlement varies.
# The baseLimit formula is the most conservative estimate, NOT a guarantee.
#
# Operator Strategies:
#   - serviceFactor NOT SET: Use baseLimit formula - most conservative
#   - serviceFactor < (baseLimit / appStake): Even more conservative
#   - serviceFactor > (baseLimit / appStake): Aggressive - betting on app stake increases
#
# WARNING: If effectiveLimit > baseLimit, you may do UNPAID WORK!
#
# Real-world example (mainnet-like values):
#   appStake = 1,000,000 upokt
#   numSuppliers = 50
#   proof_window_close_offset_blocks = 4
#   baseLimit = 1,000,000 / 50 / 4 = 5,000 upokt (most conservative)
#
#   Strategy examples:
#     serviceFactor not set   → effectiveLimit = 5,000 upokt (most conservative)
#     serviceFactor = 0.003   → effectiveLimit = 3,000 upokt (even more conservative)
#     serviceFactor = 0.005   → effectiveLimit = 5,000 upokt (same as baseLimit)
#     serviceFactor = 0.010   → effectiveLimit = 10,000 upokt (aggressive, risk of unpaid work)
#
# Leave unset to use the most conservative baseLimit formula:
# default_service_factor: 0.005

# Per-service overrides (simple map, NOT full service config)
# service_factors:
#   eth-mainnet: 0.007   # More aggressive for high-value service
#   polygon: 0.003       # More conservative

# ==============================================================================
# Observability Configuration
# ==============================================================================
metrics:
  enabled: true
  addr: ":9092"  # Prometheus metrics HTTP server

pprof:
  enabled: true  # Enable pprof profiling (for debugging, disable in production)
  addr: ":6060"  # Pprof HTTP server (use localhost for security)

logging:
  level: "debug"  # trace, debug, info, warn, error (localnet uses debug)
  format: "json"  # json, text (json required for Loki log level detection)
  output: "stdout"  # stdout, stderr, or file path
  async: true  # Enable async logging for better performance
  async_buffer_size: 100000  # Async log buffer size
  enable_caller: false  # Add caller file:line to logs (~14% alloc overhead, disable in production)
  # [PRODUCTION] level: "info", enable_caller: false
